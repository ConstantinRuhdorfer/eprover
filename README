Short Installation Instructions for the impatient
-------------------------------------------------

This assumes that you have GNU tar, bash and gawk in your search path!

Simple installation (will install executables):

> tar -xzf E.tgz 
> cd E
> vi Makefile.vars
> Set EXECPATH to the directory the programs should live in
> make install
> make install-exec
> /path/to/EXECDIR/eprover -h | more

Simplest installation (in-place):

> tar -xzf E.tgz 
> cd E
> make install
> cd PROVER
> eprover -h | more


Additional information for the CASC organizers:

Problem format for both E and EP 0.8:

tptp2X -f tptp -t rm_equality:rstfp

Command lines

eprover -xAuto -tAuto --tptp-in -s --memory-limit=384 %s
eproof  -xAuto -tAuto --tptp-in --memory-limit=384 %s

You can (but don't have to and, if not necessary, should not) add
--cpu-limit=%d for either program or for both.

Output:
# TSTP exit status: Unsatisfiable
# TSTP exit status: Satisfiable
# TSTP exit status: ResourceOut
# TSTP exit status: GaveUp

Proof Object:

# Proof object starts here.
# Proof object ends here.


Read the rest of this file if anything fails.



             The Equational Theorem Prover E
             ===============================


This is the README file for version 0.8pre "Steinthal" of the E
equational theorem prover. This version of E is free software, see the
file COPYING for details about the license and the fact that THERE IS
NO WARRANTY!  If you are interested in a proprietary version of E with
support, see below.

Release 0.71 is a minor release, improving mostly the search
heuristics, and support tools, and fixing a few bugs and portability
problems. However, the performance in automatic mode has increased
significantly, so it should be worth updating even from version 0.7.

If you are using gcc 2.95.1, 2.96.X or 2.97.X, please read DOC/PORTING
for important information (hint: Get a new compiler. Yes, there are
workarounds.). The same seems to hold for some versions of GCC 3.2.X


What is E? What is CLIB?
------------------------

E is an equational theorem prover. That means it is a program that you
can stuff a mathematical specification (in clausal logic with
equality) and a hypothesis into, and which will then run forever,
using up all of your machines resources. Very occasionally it will
find a proof for the hypothesis and tell you so ;-).

CLIB is a collection of library functions for building one class of
interesting and cool programs. Interesting and cool programs read a
specification file (or multiple files), process the input, and print a
result, or they are games. Examples for cool and interesting programs
are DISCOUNT (a distributed theorem prover), proof (a proof
transformation tool), DOOM (a game) and xevil (also a game). The sole
exception to this rule is EMACS, which is interesting and cool despite
being interactive and not a game. But it has a LISP interpreter, which
is very much like a game....

At the moment CLIB is more suited for theorem provers and similar
programs, and less useful for games. This will probably change as soon
as the game potential of theorem provers is recognized...

CLIB is layered, with higher layers becoming more specialized. Lower
levels take care of the scientifically uninteresting, but necessary
services for production-quality efficient programs, e.g. error
handling, memory management, parsing of input, etc. They should be
useful for most programs (even for some interactive programs). 

Higher level modules implement shared and unshared terms, equations,
clauses and related stuff.

My aim in writing this library is to ease the development of E and a
couple of auxiliary programs. While I try to keep new features useful
for other purposes, this aim determines which features I myself will
add. In fact, E and CLIB are now so intertwined that you will not find
a pure CLIB anymore.

CLIB and E have been created and are currently maintained by Stephan
Schulz, <schulz@informatik.tu-muenchen.de>. They are developed and
distributed under the GNU General Public License. However, you may
possibly come around versions sold or given to you under a different
license, probably by Safelogic A.B. in Gothenburg, Sweden. Safelogic
bought the right to distribute (and relicense) closed-source versions
of E with proprietary modifications. If you are interested in their
modifications, want a proprietary version with supporCSt, or want to
relicense a modified version under a non-GPL license, you can contact
them at <johan.alfredsson@safelogic.se> or visit them on the web at
http://www.safelogic.se.

The E homepage can be found at
http://www4.informatik.tu-muenchen.de/~schulz/WORK/eprover.html.


Installation:
-------------

E can be installed anywhere in the file system, either by a normal
user or by the system administrator.

To install the package, unpack the distribution (if you are reading
this, you probably already did):

  gunzip -c E.tgz|tar -xvf - 

  or 

  (g)tar -xzf E.tgz   (if you have GNU tar)

This should create a directory named E. After unpacking, edit
E/Makefile.vars to your liking. In particular, if building for HPUX,
comment out the suitable CFLAGS definition (for most systems, the
default definition should be ok).

  cd E
  make install

to compile and install the library and all included programs under the
E directory. If you want to use the prover "eprover" and the
wrapper script "eproof" anywhere except in the E/PROVER directory,
set the EXECPATH variable in Makefile.vars to a suitable directory and
type

  make install-exec

Type 

  make documentation

to translate the rudimentary LaTeX documentation (this requires
LaTeX2e and the packages theorem, amssymb and epsfig, which are
included in most current LaTeX distributions). For some operating
systems, especially if you do not have the GNU gcc compiler installed,
you may need to edit Makefile.vars to select tools and options. If you
have any problems, look into E/DOC/PORTING.

After installation, go to E/PROVER and type 

  ./eprover BOO001-1+rm_eq_rstfp.lop

to see the prover in action. Type 

  ./eprover BOO007-2+rm_eq_rstfp.lop

for a harder example. "./eprover -h" will give you some information and
a list of options.

For impatient people who do not want to read anything: 

  eprover -tAuto -xAuto --memory-limit=<80%_of_your_main_memory> <problem-file> 

should give a reasonable performance on a large class of problems
(unless your main memory is really small).

One of the new features of E is the ability to produce semi-readable
proofs. To use this, type

  eprover -l4 <other-stuff> | epclextract

or use the wrapper-script

  eproof <any options> problem

You can check the output of epclextract (and eproof) for correctness
using the tool checkproof in the same directory. "checkproof -h"
should give you all necessary information.


Directory overview:
-------------------

DOC:


  - Documentation, including a very preliminary LaTeX manual for (at
    the moment) parts of the library and the prover. You should be
    looking there instead of reading this file ;-)

    Also has the project HISTORY file and some short notes on
    porting.

include:

  - Symbolic links to all user-relevant header files

lib:

  - Symbolic links to the individual library modules

BASICS:
INOUT:
TERMS:
ORDERINGS:
CLAUSES:
ANALYSIS:
LEARN:
HEURISTICS:
PCL2:
CONTROL:

  - Sources and object files for the individual library modules

TEST:

  - Test programs for development work

SIMPLE_APPS:

  - Small application programs for demonstration purposes as well as
    for solving simple tasks.

PROVER:

  - The main program for the E prover, also contains some examples and
    stuff, as well as all the major support programs for E.

SKELETONS:

  - Skeleton files for source files, make files, comment boxes,...


EXAMPLE_PROBLEMS:

  - Example problems taken from the TPTP 2.1.0 library.

EXTERNAL:

  - Code that does not belong to the core prover but uses it or parts
    of it. Not fully maintained by me, check the headers.














